我是从某宝买的一个STM32的单片机，CPU是STM32F407ZGT6，这个一个ARM-V7架构的cotex-M4核心的CPU，并且板子上附加了一些外设，可以帮助我学习ARM架构，RTOS，以及总线等必要的知识。下面记录一下这两天折腾的东西。
# 1.工具
商家教程里面配套的软件，比如KEIL，个人用起来不太顺手，因为工作的时候都是用公司定制版的VS CODE，所以感觉还是用VS CODE比较方便，插件也很丰富，另外使用VS CODE做嵌入式开发应该也是目前的主流趋势。由于商家没有配套的教程，所以自己折腾了一番，也算是稍有收获，这里记录一下。
## 1.1 关于平台
工作的时候做代码开发和测试都是在Linux系统上进行的，对于一些常用的命令使用或者脚本开发，在Linux上更顺手，所以这里还是决定在Linux系统上做开发，同时VS CODE作为一个前端界面，远程连接Linux执行机。这里有很多方法，如果资源充足，那就搞一台装了Linux系统的执行机，然后在Windows工作机上远程连接，但是我只有一台电脑，所以使用了微软提供的解决方案WSL，WSL全称Windows Subsystem for Linux，允许用户直接在Windows上运行原生的Linux环境和应用程序，无需使用传统虚拟机或双启动设置，安装和使用方式如下：
(1)win+R，输入cmd打开powershell，执行
`wsl --install`
此命令将自动启用WSL功能并安装默认的Ubuntu发行版。安装完成后需重启计算机。
(2)在VS CODE扩展商店中搜索WSL扩展并安装
(3)Ctrl+Shift+P打开命令面板，输入WSL:Connect to WSL，执行后VS CODE会重新加载，如果左下角显示"WSL:Ubuntu"就说明已经连上了
(4)打开终端，在/home/usrname/中创建自己的目录，后面开发建议在自己的目录中进行，不要用Windows系统的挂载目录(/mnt/xx)
## 1.2 关于代码托管
这里我使用了GitHub，目前基本上所有的代码托管平台都是基于Git，是目前的主流。如果GitHub连不上可以挂个梯子。
## 1.3 关于编译工具
现代C/CXX项目主流是使用cmake作为编译工具，因为Makefile实在过于抽象，而cmake则通过写CMakeLists.txt且有大量的函数可以直接用，能够清晰简洁地构建起整个项目，所以编译工具选择cmake。
CMake在Linux系统上的默认生成器是‌Unix Makefiles，如果运行cmake时未指定生成器，会自动生成一个Makefile，然后直接make编译项目即可。如果想要指定生成器，如Ninja，则需要通过-G参数指定，如`cmake -G Ninja ..`，然后执行`ninja`编译项目，但是要提前安装ninja
由于我是在x86架构的计算机上编译arm架构的可执行文件，因此需要交叉编译工具链，我的单片机的CPU核心是cortex-m4，目前编译的代码是不带操作系统的裸机程序，所以交叉编译工具链选`arm-none-eabi-xx`，`none`就表示没有操作系统，不过后面即使上了RTOS也还是这个工具链。
## 1.4 关于程序烧录
买单片机的时候同时买了他们家的DAP调试器，上面提供了SWD、V-UART和JTAG接口。使用开源片上调试器openocd(Open On-Chip Debugger)进行代码烧录和调试，它可以通过swd等接口对MCU进行调试。
在终端中执行
`openocd -f interface/cmsis-dap.cfg -f target/stm32f4x.cfg -c "init; reset halt; program stm32_1.elf verify reset; resume"`
就可以将编译出的elf文件烧录到flash中（这里elf文件需要添加相对路径，我这里没有加是因为elf文件就在本目录）。这里面会遇到一个问题，就是WSL识别不到USB端口，这是因为WSL本身不支持USB设备访问，所以我们需要把连接DAP的那个USB端口绑定到WSL上，这需要用到一个工具usbipd-win，在Windows下执行，步骤如下：
```
winget install --interactive --exact dorssel.usbipd-win  # power shell安装usbipd-win
usbipd list  # 列出所有的USB设备，里面有BUSID信息，后面绑定要用
usbipd bind --busid <BusID>  # 绑定连接到DAP的那个USB设备，绑定后USB状态变成Shared
usbipd attach --auto-attach --wsl --busid <BusID>  # 将该设备附加到WSL，此时该设备已挂载到WSL，Windows将无法再使用它。auto-attach的作用是设备重启后自动附加到WSL
usbipd detach --busid <BusID> # 断开连接，用完后可以断开连接，USB设备回归到Windows
```
这里有必要解释下openocd命令后面的几个参数，
`-f interface/cmsis-dap.cfg`
指定调试器接口配置，这里选择了`cmsis-dap.cfg`文件，表示使用CMSIS-DAP协议，这是一种由ARM定义的通用调试接口标准。除此之外openocd还支持很多类型的协议，具体可以在./安装目录/share/openocd/scripts/interface/中查看。*.cfg的内容就是一些配置命令，比如我本地的cmsis-dap.cfg中就只有一条命令`adapter driver cmsis-dap`。
`-f target/stm32f4x.cfg`
指定目标芯片配置，这个配置文件包含了芯片的详细信息，如端序，内存映射，CPU类型等。如果芯片类型不是stm32f4系列的，可以在./安装目录/share/openocd/scripts/target/中查找。
`-c "init; reset halt; program stm32_1.elf verify reset; resume"`
openocd启动后按顺序会执行双引号中的一系列命令，命令之间用";"隔离。下面介绍一下这些命令：
 - init
初始化。根据前面加载的配置文件，建立与调试器和目标芯片的通信连接。必须首先执行，之后才能操作目标芯片。
 - reset halt
复位并暂停。对目标芯片执行一个硬件复位，但在CPU执行第一条指令前就将其停止（halt）。
这确保了芯片处于一个已知的、干净的状态，以便进行后续的flash擦写操作。如果不暂停，正在运行的程序可能会干扰烧录过程。
 - program stm32_1.elf verify reset
编程、验证、复位。这是实际烧录固件的核心命令，它本身包含几个连续操作：
program：开始烧录。
stm32_1.elf：要烧录的文件。ELF文件不仅包含原始的二进制机器码，还包含地址、符号表等信息，openocd可以根据这些信息将代码准确地写入flash的对应地址。
verify：烧录完成后，读取flash中的内容，与ELF文件进行比对，确保烧录的数据100%正确。这是防止烧录出错的关键步骤。
reset：在验证成功后，执行一次系统复位。注意，这个复位不会让CPU“halt”，芯片将开始运行刚刚烧录进去的新程序。但在这个整体命令序列中，它马上会被下一个命令影响。
 - resume
恢复运行。让处于暂停状态的CPU继续执行。
由于上一步的 program ... reset中的 reset已经让芯片复位并准备运行，而整个命令序列最初又执行过 reset halt，所以openocd与目标的调试连接可能仍然保持着一种“暂停”状态。resume命令是明确地告诉CPU继续运行。
最终效果：芯片从复位地址（通常是0x08000000，即flash起始地址）开始，执行刚刚烧录进去的程序。
## 1.5 关于调试
openocd启动后会默认开启三个端口监听，也就是说隐式执行了以下命令：
`-c "gdb_port 3333" -c "tcl_port 6666" -c "telnet_port 4444"`
其中`gdb_port 3333`表示设置GDB服务器监听端口为3333，用法为在另一个终端中执行：
```
gdb  # 进入gdb
target extended-remote :3333
```
连接后，gdb可以发送调试命令，如设置断点，单步执行，查看变量等。
`tcl_port 6666`表示设置Tcl远程过程调用接口为6666，允许远程客户端发送Tcl脚本命令​到openocd，通常用于自动化脚本控制。
`telnet_port 4444`表示设置telnet命令行端口为4444，用户可以通过telnet连接openocd并发送命令，连接也很简单，直接在另一个终端中`telnet localhost 4444`即可。openocd拥有极其丰富的调试命令，可以帮助我们做调试、内存访问、断点、监控、脚本控制等，详情见[openocd命令](openocd命令.md ':include')。

# 2.特殊文件
从项目目录中可以看到，根目录下有两个特殊文件，`startup_stm32f407xx.s`和`STM32F407XX_FLASH.ld`，这两个文件是STM32嵌入式项目的两个核心配置文件，下面简单介绍下功能：
## 2.1 startup_stm32f407xx.s
这是一个用汇编语言编写的文件，主要作用是在MCU上电或复位后，执行硬件初始化
核心作用包括：
 - 初始化栈指针 (Stack Pointer):
为C语言函数调用和局部变量分配内存空间，这是C程序运行的基本前提。
 - 设置向量表 (Vector Table):
在内存的固定位置（通常是flash起始地址）创建一个“中断向量表”。这个表是一个函数指针数组，其中第一个条目是“主栈指针”的初始值，第二个条目指向Reset_Handler​（复位处理函数，也定义在该文件中）。后续条目分别对应芯片支持的所有中断（如定时器中断、串口中断、外部引脚中断等）的处理函数入口地址。当发生中断时，CPU会自动查找这个表并跳转到对应的中断服务程序。
 - 执行复位处理程序Reset_Handler:
这是启动文件的核心函数。它依次执行：
1.从flash复制.data段到RAM：将初始化的全局变量、静态变量从只读的flash搬运到可读写的RAM中，确保程序可以修改它们的值。
2.在RAM中清零.bss段：将未初始化的全局变量、静态变量所在的内存区域清零，确保它们从0开始。
3.调用系统初始化函数（如SystemInit，通常用于配置芯片的时钟系统，比如设置为168MHz主频）。
4.最终跳转到C语言的main()函数。
## 2.2 STM32F407XX_FLASH.ld
这个文件指导链接器如何将编译器生成的一堆.o目标文件组装成一个完整、有序的可执行文件elf。
核心作用包括：
 - 定义存储器布局：
精确指定目标芯片flash（用于存储程序代码和只读数据）和RAM（用于运行时的变量）的起始地址和大小。
 - 控制程序各部分的存放位置：
将不同的代码和数据段分配到指定的存储器区域。
.text段：存放程序代码（机器指令）和常量字符串，通常放在flash中。
.data段：存放已初始化的全局/静态变量，它的初始值存放在flash，但在启动时会被startup_xx.s复制到RAM。
.bss段：存放未初始化的全局/静态变量，在启动时由startup.s在RAM中清零。
.rodata段：存放只读数据，放在flash中。
 - 设置入口点：
通常指定为Reset_Handler（在startup_xx.s中定义），确保程序从正确的启动代码开始执行。

# 3.启动流程
这里简单描述一下芯片上电后的启动流程。
flash的起始地址存放了中断向量表，中断向量表本质是一个函数指针数组，它的前两个条目一般是固定的，第一个word的内容是栈顶地址，第二个word的内容是Reset_Handler复位处理函数的地址，该函数的作用见2.1。芯片上电后，启动流程如下：
上电复位  ->  CPU读取flash起始地址0x08000000处的值，存入SP  ->  CPU读取下一个地址0x08000004处的值，存入PC，即此时PC指向Reset_Handler  ->  取指、译码、执行